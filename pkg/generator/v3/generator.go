// Package v3 implements OpenAPI 3.x specification generation.
package v3

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"gopkg.in/yaml.v3"

	openapi "github.com/fsvxavier/nexs-swag/pkg/openapi/v3"
)

// Generator generates OpenAPI 3.x specification files.
type Generator struct {
	spec           *openapi.OpenAPI
	outputDir      string
	outputType     []string
	instanceName   string
	generatedTime  bool
	templateDelims []string // [leftDelim, rightDelim]
}

// New creates a new OpenAPI 3.x Generator instance.
func New(spec *openapi.OpenAPI, outputDir string, outputType []string) *Generator {
	return &Generator{
		spec:          spec,
		outputDir:     outputDir,
		outputType:    outputType,
		instanceName:  "docs",
		generatedTime: false,
	}
}

// SetInstanceName sets the package name for generated Go file.
func (g *Generator) SetInstanceName(name string) {
	g.instanceName = name
}

// SetGeneratedTime sets whether to include generation timestamp.
func (g *Generator) SetGeneratedTime(enabled bool) {
	g.generatedTime = enabled
}

// SetTemplateDelims sets custom template delimiters.
// Format: "leftDelim,rightDelim".
func (g *Generator) SetTemplateDelims(delims string) {
	if delims == "" {
		g.templateDelims = []string{"{{", "}}"}
		return
	}
	parts := strings.Split(delims, ",")
	if len(parts) == 2 {
		g.templateDelims = []string{strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])}
	} else {
		g.templateDelims = []string{"{{", "}}"}
	}
}

// Generate generates the OpenAPI specification files.
func (g *Generator) Generate() error {
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate each requested output type
	for _, outputType := range g.outputType {
		switch outputType {
		case "json":
			if err := g.generateJSON(); err != nil {
				return fmt.Errorf("failed to generate JSON: %w", err)
			}
		case "yaml", "yml":
			if err := g.generateYAML(); err != nil {
				return fmt.Errorf("failed to generate YAML: %w", err)
			}
		case "go":
			if err := g.generateGo(); err != nil {
				return fmt.Errorf("failed to generate Go file: %w", err)
			}
		default:
			return fmt.Errorf("unsupported output type: %s", outputType)
		}
	}

	return nil
}

// generateJSON generates the OpenAPI specification in JSON format.
func (g *Generator) generateJSON() error {
	filePath := filepath.Join(g.outputDir, "openapi.json")

	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer func() {
		if cerr := file.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")

	if err := encoder.Encode(g.spec); err != nil {
		return err
	}

	fmt.Printf("Generated: %s\n", filePath)
	return nil
}

// generateYAML generates the OpenAPI specification in YAML format.
func (g *Generator) generateYAML() error {
	filePath := filepath.Join(g.outputDir, "openapi.yaml")

	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer func() {
		if cerr := file.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}()

	encoder := yaml.NewEncoder(file)
	encoder.SetIndent(2)

	if err := encoder.Encode(g.spec); err != nil {
		return err
	}

	fmt.Printf("Generated: %s\n", filePath)
	return nil
}

// generateGo generates a Go file with embedded OpenAPI specification.
func (g *Generator) generateGo() error {
	filePath := filepath.Join(g.outputDir, "docs.go")

	// Marshal to JSON for embedding
	jsonData, err := json.MarshalIndent(g.spec, "", "  ")
	if err != nil {
		return err
	}

	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer func() {
		if cerr := file.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}()

	// Write package declaration
	if _, err := fmt.Fprintf(file, "// Package %s Code generated by nexs-swag. DO NOT EDIT\n", g.instanceName); err != nil {
		return err
	}

	if g.generatedTime {
		if _, err := fmt.Fprintf(file, "// Generated at: %s\n", time.Now().Format("2006-01-02 15:04:05")); err != nil {
			return err
		}
	}

	if _, err := fmt.Fprintf(file, "package %s\n\n", g.instanceName); err != nil {
		return err
	}

	// Write SwaggerDoc variable
	if _, err := fmt.Fprintln(file, "// SwaggerDoc is the OpenAPI v3 specification in JSON format"); err != nil {
		return err
	}

	// Apply template delimiters if configured
	leftDelim := "{{"
	rightDelim := "}}"
	if len(g.templateDelims) == 2 {
		leftDelim = g.templateDelims[0]
		rightDelim = g.templateDelims[1]
	}

	docStr := string(jsonData)
	docStr = strings.ReplaceAll(docStr, "{{", leftDelim)
	docStr = strings.ReplaceAll(docStr, "}}", rightDelim)

	if _, err := fmt.Fprintf(file, "var SwaggerDoc = `%s`\n\n", docStr); err != nil {
		return err
	}

	// Write ReadDoc function
	if _, err := fmt.Fprintln(file, "// ReadDoc returns the OpenAPI specification"); err != nil {
		return err
	}

	if _, err := fmt.Fprintln(file, "func ReadDoc() string {"); err != nil {
		return err
	}

	if _, err := fmt.Fprintln(file, "\treturn SwaggerDoc"); err != nil {
		return err
	}

	if _, err := fmt.Fprintln(file, "}"); err != nil {
		return err
	}

	fmt.Printf("Generated: %s\n", filePath)
	return nil
}
